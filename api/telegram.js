// api/telegram.js ‚Äî Telegram webhook (Vercel, Node 20, ESM)
// FSM: Q1 consent -> Q2 name -> Q3 interests (multi) -> Q4 stack (multi)
// –î–æ–±–∞–≤–ª–µ–Ω–æ: –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ –∞–Ω–∫–µ—Ç—ã (üîÅ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ / /reset / ¬´–∑–∞–Ω–æ–≤–æ¬ª), run_id + started_at

const TOKEN        = process.env.TELEGRAM_BOT_TOKEN;
const ADMIN_ID     = process.env.ADMIN_CHAT_ID || "";
const START_SECRET = process.env.START_SECRET || "";
const REQUIRE_SEC  = /^1|true$/i.test(process.env.REQUIRE_SECRET || "");
const REDIS_BASE   = (process.env.UPSTASH_REDIS_REST_URL || "").replace(/\/$/, "");
const REDIS_TOKEN  = process.env.UPSTASH_REDIS_REST_TOKEN || "";

const NO_CHAT = "–Ø –Ω–µ –≤–µ–¥—É –ø–µ—Ä–µ–ø–∏—Å–∫—É ‚Äî –∏—Å–ø–æ–ª—å–∑—É–π –∫–Ω–æ–ø–∫–∏ –Ω–∏–∂–µ üôå";

const A_INTERESTS = [
  "Backend","Graph/Neo4j","Vector/LLM","Frontend",
  "DevOps/MLOps","Data/ETL","Product/Coordination"
];
const A_STACK = [
  "Python/FastAPI","PostgreSQL/SQL","Neo4j","pgvector",
  "LangChain/LangGraph","React/TS","Docker/K8s/Linux","CI/GitHub"
];

/* ---------------- Redis (Upstash REST) ---------------- */

function rUrl(path) {
  if (!REDIS_BASE || !REDIS_TOKEN) throw new Error("Redis env missing");
  return new URL(REDIS_BASE + path);
}
async function rGET(path) {
  const res = await fetch(rUrl(path), { headers: { Authorization: `Bearer ${REDIS_TOKEN}` } });
  return res.json();
}
async function rCall(path, qs) {
  const url = rUrl(path);
  if (qs) for (const [k, v] of Object.entries(qs)) url.searchParams.set(k, String(v));
  const res = await fetch(url, { headers: { Authorization: `Bearer ${REDIS_TOKEN}` } });
  return res.json();
}
const rSet  = (k, v, qs)=> rCall(`/set/${encodeURIComponent(k)}/${encodeURIComponent(v)}`, qs);
const rGet  = (k)=> rGET(`/get/${encodeURIComponent(k)}`);
const rDel  = (k)=> rGET(`/del/${encodeURIComponent(k)}`);
const rIncr = async (k, ex)=> {
  const j = await rGET(`/incr/${encodeURIComponent(k)}`);
  if (j.result === 1) await rGET(`/expire/${encodeURIComponent(k)}/${ex || 60}`);
  return j.result;
};

// true = –ø–µ—Ä–≤—ã–π —Ä–∞–∑; false = —è–≤–Ω—ã–π –¥—É–±–ª—å; –ø—Ä–∏ –æ—à–∏–±–∫–µ ‚Äî true (–Ω–µ —Ç–µ—Ä—è–µ–º –∞–ø–¥–µ–π—Ç—ã)
async function seenUpdate(update_id) {
  try {
    const j = await rSet(`upd:${update_id}`, "1", { EX: 180, NX: true });
    return j && Object.prototype.hasOwnProperty.call(j, "result") ? j.result === "OK" : true;
  } catch {
    return true;
  }
}
async function overRL(uid, limit) {
  try { return (await rIncr(`rl:${uid}`, 60)) > (limit || 12); }
  catch { return false; }
}
async function notifyOnce(uid, tag, ttlSec) {
  try {
    const j = await rSet(`note:${uid}:${tag}`, "1", { EX: ttlSec || 6, NX: true });
    return j.result === "OK";
  } catch { return true; }
}
function newRunSession() {
  return {
    run_id: `${Date.now().toString(36)}_${Math.random().toString(36).slice(2,8)}`,
    started_at: new Date().toISOString(),
    step: "consent",
    consent: "",
    name: "",
    interests: [],
    stack: []
  };
}
async function getSess(uid) {
  try {
    const j = await rGet(`sess:${uid}`);
    if (!j?.result) return newRunSession();
    let s; try { s = JSON.parse(j.result); } catch { return newRunSession(); }
    if (!Array.isArray(s.interests)) s.interests = [];
    if (!Array.isArray(s.stack)) s.stack = [];
    if (!s.run_id) s.run_id = newRunSession().run_id;
    if (!s.started_at) s.started_at = new Date().toISOString();
    return s;
  } catch { return newRunSession(); }
}
async function putSess(uid, s) { try { await rSet(`sess:${uid}`, JSON.stringify(s), { EX:21600 }); } catch {} }
async function delSess(uid)     { try { await rDel(`sess:${uid}`); } catch {} }

/* ---------------- Telegram API ---------------- */

async function tg(method, payload) {
  const url = `https://api.telegram.org/bot${TOKEN}/${method}`;
  try {
    const res = await fetch(url, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(payload)
    });
    const json = await res.json();
    if (!json?.ok) console.error("tg api error:", method, JSON.stringify(json).slice(0, 500));
    return json;
  } catch (e) {
    console.error("tg network error:", method, e?.message || String(e));
    return { ok:false, error:"network" };
  }
}

/* ---------------- Body parsing ---------------- */

async function readBody(req) {
  if (req.body) {
    try { return typeof req.body === "string" ? JSON.parse(req.body) : req.body; }
    catch {}
  }
  let raw = "";
  for await (const chunk of req) raw += Buffer.isBuffer(chunk) ? chunk.toString("utf8") : String(chunk);
  try { return JSON.parse(raw || "{}"); } catch { return {}; }
}

/* ---------------- UI helpers ---------------- */

function consentKeyboard() {
  return JSON.stringify({
    inline_keyboard: [[
      { text:"‚úÖ –°–æ–≥–ª–∞—Å–µ–Ω –Ω–∞ —Å–≤—è–∑—å", callback_data:"consent_yes" },
      { text:"‚ùå –ù–µ —Å–µ–π—á–∞—Å",        callback_data:"consent_no"  }
    ]]
  });
}
function continueOrResetKb() {
  return JSON.stringify({
    inline_keyboard: [[
      { text:"‚ñ∂Ô∏è –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å",     callback_data:"continue"    },
      { text:"üîÅ –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ",  callback_data:"reset_start" }
    ]]
  });
}
function multiKb(prefix, options, selected) {
  const rows = options.map(o => ([{ text:`${selected.includes(o) ? "‚òëÔ∏è" : "‚¨úÔ∏è"} ${o}`, callback_data:`${prefix}:${o}` }]));
  rows.push([{ text:"–î–∞–ª—å—à–µ ‚ûú", callback_data:`${prefix}:next` }]);
  return JSON.stringify({ inline_keyboard: rows });
}
async function sendWelcome(chat, uid) {
  console.log("sendWelcome", { uid, chat });
  await tg("sendMessage", {
    chat_id: chat,
    text: "–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ –±—ã—Å—Ç—Ä—ã–π –æ—Ç–±–æ—Ä ¬´—Å—Ç—Ä–∞—Ç–µ–≥–∏—á–µ—Å–∫–∏—Ö –ø–∞—Ä—Ç–Ω—ë—Ä–æ–≤¬ª (SQL + Graph + Vector).\n–°–æ–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ —Ä–∞–±–æ—á–∏–µ –æ—Ç–≤–µ—Ç—ã: –∏–Ω—Ç–µ—Ä–µ—Å—ã, —Å—Ç–µ–∫, —Å—Ç–∏–ª—å, –≤—Ä–µ–º—è. –û–∫?",
    parse_mode: "HTML",
    reply_markup: consentKeyboard()
  });
}
async function sendNamePrompt(chat, uid, username) {
  console.log("sendNamePrompt", { uid, chat, username });
  const btn = username ? { text:`–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å @${username}`, callback_data:"name_use_username" } : null;
  const rm  = btn ? JSON.stringify({ inline_keyboard: [[btn]] }) : undefined;
  await tg("sendMessage", {
    chat_id: chat,
    text: "2) –ö–∞–∫ –∫ —Ç–µ–±–µ –æ–±—Ä–∞—â–∞—Ç—å—Å—è? –í–≤–µ–¥–∏ –∏–º—è —Ç–µ–∫—Å—Ç–æ–º" + (username?` –∏–ª–∏ –Ω–∞–∂–º–∏ ¬´–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å @${username}¬ª.`:""),
    parse_mode: "HTML",
    reply_markup: rm
  });
}
async function sendInterestsPrompt(chat, uid, s) {
  console.log("sendInterests", { uid, run: s.run_id });
  await tg("sendMessage", {
    chat_id: chat,
    text: "3) –ß—Ç–æ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–µ–µ 3‚Äì6 –º–µ—Å.? (–º—É–ª—å—Ç–∏–≤—ã–±–æ—Ä, –ø–æ–≤—Ç–æ—Ä–Ω–æ–µ –Ω–∞–∂–∞—Ç–∏–µ —Å–Ω–∏–º–∞–µ—Ç)",
    parse_mode: "HTML",
    reply_markup: multiKb("q3", A_INTERESTS, s.interests || [])
  });
}
async function sendStackPrompt(chat, uid, s) {
  console.log("sendStack", { uid, run: s.run_id });
  await tg("sendMessage", {
    chat_id: chat,
    text: "4) –£–≤–µ—Ä–µ–Ω–Ω—ã–π —Å—Ç–µ–∫ (–º—É–ª—å—Ç–∏–≤—ã–±–æ—Ä):",
    parse_mode: "HTML",
    reply_markup: multiKb("q4", A_STACK, s.stack || [])
  });
}

/* ---------------- HTTP entry (Vercel) ---------------- */

export default async function handler(req, res) {
  if (req.method !== "POST") { res.status(200).send("OK"); return; }
  const upd = await readBody(req);

  try { console.log("HOOK:", JSON.stringify({ id: upd.update_id, msg: !!upd.message, cb: !!upd.callback_query })); } catch {}

  try {
    if (upd.update_id && !(await seenUpdate(upd.update_id))) { res.status(200).send("OK"); return; }
    if (upd.message)             await onMessage(upd.message);
    else if (upd.callback_query) await onCallback(upd.callback_query);
  } catch (e) {
    console.error("handler error:", e?.stack || e?.message || String(e));
  }
  res.status(200).send("OK");
}

/* ---------------- Handlers ---------------- */

async function resetFlow(uid, chat) {
  const s = newRunSession();
  await putSess(uid, s);
  await tg("sendMessage", {
    chat_id: chat,
    text: "üîÅ –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–Ω–æ–≤–æ ‚Äî —ç—Ç–æ –Ω–æ–≤–∞—è –ø–æ–ø—ã—Ç–∫–∞. –ü—Ä–µ–¥—ã–¥—É—â–∏–µ –æ—Ç–≤–µ—Ç—ã –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –æ—Ç–¥–µ–ª—å–Ω–æ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ –≤ –±–∞–∑—É.",
  });
  await sendWelcome(chat, uid);
}

async function continueFlow(uid, chat, s, username) {
  if (s.step === "name")        { await sendNamePrompt(chat, uid, username); return; }
  if (s.step === "interests")   { await sendInterestsPrompt(chat, uid, s);   return; }
  if (s.step === "stack")       { await sendStackPrompt(chat, uid, s);       return; }
  // –µ—Å–ª–∏ –≤–¥—Ä—É–≥ –¥—Ä—É–≥–æ–µ ‚Äî –≤–µ—Ä–Ω—ë–º –∫ –Ω–∞—á–∞–ª—É —Ç–µ–∫—É—â–µ–π –ø–æ–ø—ã—Ç–∫–∏
  await sendWelcome(chat, uid);
}

async function onMessage(m) {
  const uid = m.from.id;
  if (await overRL(uid, 12)) return;

  const chat = m.chat.id;
  const text = (m.text || "").trim();
  try { console.log("onMessage:", { uid, text }); } catch {}

  if (text.toLowerCase() === "/ping") { await tg("sendMessage", { chat_id: chat, text: "pong ‚úÖ" }); return; }
  if (text.toLowerCase() === "/reset" || text.toLowerCase() === "–∑–∞–Ω–æ–≤–æ") { await resetFlow(uid, chat); return; }

  if (text.startsWith("/start")) {
    const payload = text.split(" ").slice(1).join(" ").trim();
    const hasSecret = payload && START_SECRET && payload.includes(START_SECRET);
    if (REQUIRE_SEC && !hasSecret && String(uid) !== String(ADMIN_ID)) {
      await tg("sendMessage", { chat_id: chat, text: `–ù—É–∂–µ–Ω –∫–ª—é—á –¥–æ—Å—Ç—É–ø–∞. –û—Ç–∫—Ä–æ–π —Å—Å—ã–ª–∫—É:\nhttps://t.me/rgnr_assistant_bot?start=${encodeURIComponent(START_SECRET || "INVITE")}` });
      return;
    }
    const s = await getSess(uid);
    if (s.step && s.step !== "consent") {
      // —á—Ç–æ–±—ã –Ω–µ —Å–ø–∞–º–∏—Ç—å ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º Continue/Reset –Ω–µ —á–∞—â–µ, —á–µ–º —Ä–∞–∑ –≤ 6 —Å–µ–∫
      if (await notifyOnce(uid, "cont", 6)) {
        await tg("sendMessage", {
          chat_id: chat,
          text: "–ê–Ω–∫–µ—Ç–∞ —É–∂–µ –Ω–∞—á–∞—Ç–∞ ‚Äî –ø—Ä–æ–¥–æ–ª–∂–∞—Ç—å –∏–ª–∏ –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ?",
          reply_markup: continueOrResetKb()
        });
      }
      return;
    }
    // –Ω–æ–≤–∞—è –ø–æ–ø—ã—Ç–∫–∞
    const s2 = newRunSession();
    await putSess(uid, s2);
    await sendWelcome(chat, uid);
    return;
  }

  const s = await getSess(uid);
  if (s.step === "name") {
    s.name = text.slice(0,80);
    s.step = "interests";
    await putSess(uid, s);
    await sendInterestsPrompt(chat, uid, s);
    return;
  }

  await tg("sendMessage", { chat_id: chat, text: NO_CHAT });
}

async function onCallback(q) {
  const uid = q.from.id;
  if (await overRL(uid, 12)) return;

  const chat = q.message.chat.id;
  const mid  = q.message.message_id;
  const data = q.data || "";

  try { await tg("answerCallbackQuery", { callback_query_id: q.id }); } catch {}

  let s = await getSess(uid);

  if (data === "continue") {
    await continueFlow(uid, chat, s, q.from.username);
    return;
  }
  if (data === "reset_start") {
    await resetFlow(uid, chat);
    return;
  }

  if (data === "consent_yes") {
    if (s.step !== "consent") return;
    s.consent = "yes"; s.step = "name";
    await putSess(uid, s);
    await tg("editMessageText", { chat_id: chat, message_id: mid, text: "‚úÖ –°–ø–∞—Å–∏–±–æ –∑–∞ —Å–æ–≥–ª–∞—Å–∏–µ –Ω–∞ —Å–≤—è–∑—å.", parse_mode:"HTML" });
    await sendNamePrompt(chat, uid, q.from.username);
    return;
  }
  if (data === "consent_no") {
    if (s.step !== "consent") return;
    await tg("editMessageText", { chat_id: chat, message_id: mid, text: "–û–∫. –ï—Å–ª–∏ –ø–µ—Ä–µ–¥—É–º–∞–µ—à—å ‚Äî /start" });
    await delSess(uid);
    return;
  }

  if (data === "name_use_username") {
    if (s.step !== "name") return;
    s.name = q.from.username ? `@${q.from.username}` : String(uid);
    s.step = "interests";
    await putSess(uid, s);
    await sendInterestsPrompt(chat, uid, s);
    return;
  }

  if (data.startsWith("q3:")) {
    if (s.step !== "interests") return;
    const opt = data.split(":")[1];
    if (opt === "next") {
      s.step = "stack";
      await putSess(uid, s);
      await sendStackPrompt(chat, uid, s);
      return;
    }
    toggleInPlace(s.interests, opt);
    await putSess(uid, s);
    await tg("editMessageReplyMarkup", {
      chat_id: chat, message_id: mid, reply_markup: multiKb("q3", A_INTERESTS, s.interests)
    });
    return;
  }

  if (data.startsWith("q4:")) {
    if (s.step !== "stack") return;
    const opt = data.split(":")[1];
    if (opt === "next") {
      s.step = "paused";
      await putSess(uid, s);
      await tg("sendMessage", { chat_id: chat, text: "‚úÖ –ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–ª –∏–Ω—Ç–µ—Ä–µ—Å—ã –∏ —Å—Ç–µ–∫. –ü—Ä–æ–¥–æ–ª–∂–∏–º –≤ —Å–ª–µ–¥—É—é—â–µ–º —à–∞–≥–µ." });
      return;
    }
    toggleInPlace(s.stack, opt);
    await putSess(uid, s);
    await tg("editMessageReplyMarkup", {
      chat_id: chat, message_id: mid, reply_markup: multiKb("q4", A_STACK, s.stack)
    });
    return;
  }
}

/* ---------------- Utils ---------------- */
function toggleInPlace(arr, val) {
  const i = arr.indexOf(val);
  if (i >= 0) arr.splice(i, 1);
  else arr.push(val);
}
